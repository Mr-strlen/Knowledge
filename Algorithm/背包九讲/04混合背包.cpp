/*
考虑到在01背包和完全背包中给出的伪代码只有一处不同
故如果只有两类物品：一类物品只能取一次，另一类物品可以取无限次
那么只需在对每个物品应用转移方程时，根据物品的类别选用顺序或逆序的循环即可
复杂度是O(VN)

如果再加上有的物品最多可以取有限次，那么原则上也可以给出O(VN)O(VN)的解法：
遇到多重背包类型的物品用单调队列解即可。但如果不考虑超过NOIP范围的算法的话
用多重背包中将每个这类物品分成O(log(p[i]))个01背包的物品的方法也已经很优了
*/
//p[i]:每个物品的件数，0代表无穷个
for (int i = 1; i <= n; i++)
    if (p[i] == 0)
        for (int j = w[i]; j <= V; j++)
            f[j] = max(f[j], f[j - w[i]] + v[i]);
    else
    for (int k = 1; k <= p[i]; k++)
        for (int j = V; j >= w[i]; j--)
            f[j] = max(f[j], f[j - w[i]] + v[i]); 
